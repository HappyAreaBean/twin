import { randomBytes } from "crypto";
import fs from "fs";
import path from "path";
import { applyPatch } from "fast-json-patch/index.mjs";
import { logger } from "./logger.js";
import { addFile, UPLOAD_DIR } from "./storage.js";
import { staticConfigs } from "./api.js";

export const continueEdit = async (req, res) => {
  try {
    const { id } = req.params;

    // Prevent against path injection
    if (!/^[a-zA-Z0-9]+$/.test(id)) return res.sendStatus(400);

    const savedPath = path.join(UPLOAD_DIR, id);
    const savedRaw = await fs.promises.readFile(savedPath, "utf-8");
    const savedObj = JSON.parse(savedRaw);

    const originName = savedObj.origin;
    let originData;

    if (staticConfigs[originName]) {
      originData = staticConfigs[originName];
    } else {
      const originPath = path.join(UPLOAD_DIR, originName);
      const originRaw = await fs.promises.readFile(originPath, "utf-8");
      originData = JSON.parse(originRaw);
    }

    const merged = await combineData(originData, savedObj);

    res.json({ origin: originName, id: merged });
  } catch (err) {
    logger.error(err);
    res.sendStatus(404);
  }
};

// !!! generated by AI !!!
// and it basically telling AI to write the code
// TwinParser: https://github.com/tritonmc/Triton/blob/v4/core/src/main/java/com/rexcantor64/triton/web/TwinParser.java
// into js
// suprisingly there are a thing called fast-json-patch which is cool
// please don't rely on this code LOL, but you get the idea
const combineData = async (originFile, savedFile) => {
  // Deep‑clone the origin so we never mutate the original object
  const mergedData = JSON.parse(JSON.stringify(originFile));

  // Delete items
  if (Array.isArray(savedFile.deleted)) {
    mergedData.data = mergedData.data.filter((item) => !savedFile.deleted.includes(item._twin?.id));
  }

  // Add
  if (Array.isArray(savedFile.added)) {
    const existingIds = new Set(mergedData.data.map((i) => i._twin?.id));
    for (const newItem of savedFile.added) {
      if (!existingIds.has(newItem._twin?.id)) {
        mergedData.data.push(newItem);
      }
    }
  }

  // Apply modifications
  if (savedFile.modified && typeof savedFile.modified === "object") {
    for (const [id, ops] of Object.entries(savedFile.modified)) {
      const idx = mergedData.data.findIndex((i) => i._twin?.id === id);
      if (idx === -1) continue; // id not present – skip

      // `applyPatch` mutates the target object; we pass a copy to keep
      // the original reference safe.
      const target = mergedData.data[idx];
      const result = applyPatch(target, ops, true);
      if (result.newDocument) mergedData.data[idx] = result.newDocument;
    }
  }

  // Merge top‑level metadata
  if (savedFile.metadata && typeof savedFile.metadata === "object") {
    mergedData.metadata = {
      ...mergedData.metadata,
      ...savedFile.metadata,
    };
  }

  // Persist the merged result as a new upload
  const newId = randomBytes(6).toString("hex");
  await addFile(newId);
  await fs.promises.writeFile(
    path.join(UPLOAD_DIR, newId),
    JSON.stringify(mergedData, null, 2),
    "utf-8"
  );

  return newId;
};
